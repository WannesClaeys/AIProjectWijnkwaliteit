---
title: 'AI Project: voorspellen wijnkwaliteit'
author: "Mano Mares & Wannes Claeys"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
library(data.table)
library(magrittr)
library(knitr)
library(readr)
library(reticulate)
library(MASS)
library(corrplot)

set.seed(42)

knitr::opts_chunk$set(echo = TRUE)

opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
```

# Opdracht

In deze opdracht is het de bedoeling om het klassieke Machine Learning proces te doorlopen a.d.h.v. een use case. Vanzelfsprekend hoort bij een model een voorspelling die vervolgens wordt geanalyseerd met echte data om de performantie/accuracy van het model te evalueren.

Use case: 
Een brouwerij in West-Vlaanderen wil graag de productie van wijnen optimaliseren door meer inzichten te vergaren over de impact van de verschillende wijn-kenmerken op de kwaliteit van de wijnen. Meer bepaald wil de brouwerij de kwaliteit van wijn voorspellen op basis van bepaalde kenmerken. Deze kenmerken zijn ondergebracht in 2 datasets, respectievelijk voor rode wijn en witte wijn. 

Deze datasets bevatten de fundamentele kenmerken die verantwoordelijk zijn voor het beïnvloeden van de kwaliteit van de wijn. Jullie doel is om, door middel van verschillende Machine Learning technieken en modellen de kwaliteit van de wijn te voorspellen.

Opmerking: als je in de voorbeeldcode 3 puntjes (...) tegenkomt, dan is het de bedoeling om de code aan te vullen.

# Runnen project

-> Welke technologieën gebruik je? (Python, R, Vs Code, R Studio)<br />
-> Hoe kan ik het project zonder execution errors runnen?

# Data-Exploratie

## Wite wijn

```{r}
data_winequality_white <- read.csv("Data - winequality-white.csv", header=TRUE, sep=";") %>% setDT
head(data_winequality_white)

```

```{r}
qualityCountWhite <- table(data_winequality_white$quality)
barplot(qualityCountWhite, main="Qualtity of white wine",
   xlab="Quality")
summary(data_winequality_white$quality)
```

```{r}
fixedAcidityWhite <- table(data_winequality_white$fixed.acidity)
d <- density(fixedAcidityWhite)
plot(d, main="Fixed acidity in the wine")
summary(data_winequality_white$fixed.acidity)

```

```{r}
volatileAcidityWhite <- table(data_winequality_white$volatile.acidity)
d <- density(volatileAcidityWhite)
plot(d, main="Volatile acidity in the wine")
summary(data_winequality_white$volatile.acidity)

```

```{r}
citricAcidWhite <- table(data_winequality_white$citric.acid)
d <- density(citricAcidWhite)
plot(d, main="Citric acid in the wine")
summary(data_winequality_white$citric.acid)
```
```{r}
residualSugarWhite <- table(data_winequality_white$residual.sugar)
d <- density(residualSugarWhite)
plot(d, main="Residual sugar in the wine")
summary(data_winequality_white$residual.sugar)
```

```{r}
chloridesWhite <- table(data_winequality_white$chlorides)
d <- density(chloridesWhite)
plot(d, main="Chlorides in the wine")
summary(data_winequality_white$chlorides)
```

```{r}
freeSulfurDioxideWhite <- table(data_winequality_white$free.sulfur.dioxide)
d <- density(freeSulfurDioxideWhite)
plot(d, main="Free sulfur dioxide in the wine")
summary(data_winequality_white$free.sulfur.dioxide)
```

```{r}
totalSulfurDioxideWhite <- table(data_winequality_white$total.sulfur.dioxide)

d <- density(totalSulfurDioxideWhite)
plot(d, main="Total sulfur dioxide in the wine")
summary(data_winequality_white$total.sulfur.dioxide)
```

```{r}
densityWhite <- table(data_winequality_white$density)
d <- density(densityWhite)
plot(d, main="Density of the wine")
summary(data_winequality_white$density)
```

```{r}
phWhite <- table(data_winequality_white$pH)
d <- density(phWhite)
plot(d, main="PH vlaue of the wine")
summary(data_winequality_white$pH)
```

```{r}
sulphatesWhite <- table(data_winequality_white$sulphates)
d <- density(sulphatesWhite)
plot(d, main="Sulphate in the wine")
summary(data_winequality_white$sulphates)
```
```{r}
alcoholWhite <- table(data_winequality_white$alcohol)
d <- density(alcoholWhite)
plot(d, main="Alcohol percentage of the wine")
summary(data_winequality_white$alcohol)
```

## Rode wijn

-> Doe nu hetzelfde voor de andere dataset. Merk op dat je met beide datasets zal moeten werken. M.a.w.: data-exploratie, data-manipulatie, trainen en testen op beide datasets.
-> Overloop alle variabelen en leg ze uit aan de hand van 1 of 2 zinnen per variabele. Geef iets weer of analyseer indien er belangrijke punten zijn die je wil vermelden.
-> Enzovoort

```{r}
data_winequality_red <- read.csv("Data - winequality-red.csv", header=TRUE, sep=";") %>% setDT
head(data_winequality_red)

```

```{r}
qualityCountRed <- table(data_winequality_red$quality)
barplot(qualityCountRed, main="Qualtity of red wine",
   xlab="Quality")
summary(data_winequality_red$quality)
```

```{r}
fixedAcidityRed <- table(data_winequality_red$fixed.acidity)
d <- density(fixedAcidityRed)
plot(d, main="Fixed acidity in the red wine")
summary(data_winequality_red$fixed.acidity)

```

```{r}
volatileAcidityRed <- table(data_winequality_red$volatile.acidity)
d <- density(volatileAcidityRed)
plot(d, main="Volatile acidity in the red wine")
summary(data_winequality_red$volatile.acidity)

```

```{r}
citricAcidRed <- table(data_winequality_red$citric.acid)
d <- density(citricAcidRed)
plot(d, main="Citric acid in the red wine")
summary(data_winequality_red$citric.acid)
```
```{r}
residualSugarRed <- table(data_winequality_red$residual.sugar)
d <- density(residualSugarRed)
plot(d, main="Residual sugar in the red wine")
summary(data_winequality_red$residual.sugar)
```

```{r}
chloridesRed <- table(data_winequality_red$chlorides)
d <- density(chloridesRed)
plot(d, main="Chlorides in the red wine")
summary(data_winequality_red$chlorides)
```

```{r}
freeSulfurDioxideRed <- table(data_winequality_red$free.sulfur.dioxide)
d <- density(freeSulfurDioxideRed)
plot(d, main="Free sulfur dioxide in the red wine")
summary(data_winequality_red$free.sulfur.dioxide)
```

```{r}
totalSulfurDioxideRed <- table(data_winequality_red$total.sulfur.dioxide)

d <- density(totalSulfurDioxideRed)
plot(d, main="Total sulfur dioxide in the red wine")
summary(data_winequality_red$total.sulfur.dioxide)
```

```{r}
densityRed <- table(data_winequality_red$density)
d <- density(densityRed)
plot(d, main="Density of the red wines")
summary(data_winequality_red$density)
```

```{r}
phRed <- table(data_winequality_red$pH)
d <- density(phRed)
plot(d, main="PH vlaue of the red wines")
summary(data_winequality_red$pH)
```

```{r}
sulphatesRed <- table(data_winequality_red$sulphates)
d <- density(sulphatesWhite)
plot(d, main="Sulphate in the wine")
summary(data_winequality_red$sulphates)
```
```{r}
alcoholRed <- table(data_winequality_red$alcohol)
d <- density(alcoholRed)
plot(d, main="Alcohol percentage of the wine")
summary(data_winequality_red$alcohol)
```


Analyseerde afhankelijkheid tussen de variabelen door middel van een correlatie matrix en een correlatietabel.

```{r}
red_wine.cor = cor(data_winequality_red)
round(red_wine.cor, 2)
corrplot(red_wine.cor)
```

```{r}
white_wine.cor = cor(data_winequality_white)
round(white_wine.cor, 2)
corrplot(white_wine.cor)
```
-> Wat zijn de conclusies uit je bovenstaand matrix en/of tabel?


## Conclusie Data-Exploratie

-> Geef een algemene conclusie over je data-exploratie, waarin je reflecteert over de inzichten die je hebt opgedaan, opmerkelijkheden benadrukt en de volgende stappen in het proces beschrijft.<br />
-> Leg ook uit of je iets van data dient te 'manipuleren', (lees: data-manipulatie). Het kan bijvoorbeeld zijn dat er een variabele is met corrupted data of dergelijke. Daarnaast is het belangrijk dat de datatypes van de dataset compatibel zijn met de gebruikte ML algoritmen. Om dit te weten moet je even nadenken over welke 3 ML algoritmen je wil gebruiken voor je voorspelling.

### Witte wijn

We zien een sterke correclatie tussen "fixed acid" en "citric acid", alsook tussen "volatile acidity" en "citric acid". Dit is logisch, er is steeds sprake over soorten zuren in de wijn.
Er is een minder sterke correlatie tussen "volatile acid" en "fixed acid". 

### Rode Wijn



# Data-Manipulatie

```{r}
data_winequality_white <- na.omit(data_winequality_white)
```
```{r}
data_winequality_red <- na.omit(data_winequality_red)
```

## Conclusie Data-Manipulatie




# Leeralgoritmen/Neurale Netwerken

-> Merk op: je kan dit probleem aanpakken als een regressieprobleem, maar ook als een classificatieprobleem. Let het verschil uit in de context van deze probleemstelling. Leg ook uit wat volgens jou de beste aanpak is.<br />
-> Selecteer nu 3 algoritmen: 2 algoritmen voor wat volgens jou de beste aanpak is, 1 algoritme voor de andere aanpak. <br /><br />

-> Start hieronder met het opstellen van jullie modellen en de voorspellingen voor elk van de 3 algoritmen. M.a.w.: aangezien jullie 3 algoritmen zullen gebruiken, zullen jullie 3 keer een model gebruiken en teven 3 keer voorspellen.<br />

-> Analyseer de resultaten van elk algoritme <br />
-> Concludeer over de de probleemstelling, het proces en de resultaten van elk model. Welk model past volgens jou het beste bij deze probleemstelling?


### Algoritme 1: LM() algoritme

**Witte wijn:**

De data wordt gesplitst in een trainingsset en testset. Vervolgens wordt het model gemaakt met de trainingsset.

```{r}
dt_white = sort(sample(nrow(data_winequality_white), nrow(data_winequality_white)*.8))
traindata_white <- data_winequality_white[dt_white,]
testdata_white <- data_winequality_white[-dt_white,]

model_white <- lm(quality ~., data = traindata_white)
```

Nu het model gemaakt is, kan met de testset voorspellingen worden gemaakt. Het verschil tussen de werkelijke kwaliteit en de voorspelde kwaliteit wordt ook weergegeven.

```{r}
prediction_quality_white <- predict(model_white, newdata = testdata_white)

result_white <- data.frame(testdata_white$quality, prediction_quality_white, margin_of_error = testdata_white$quality - prediction_quality_white)

head(result_white)
```
Om de kwaliteit van het model te evalueren, wordt de mean absolute error gebruikt. Hoe kleiner de error, hoe beter het model. 

```{r}
mae <- function(x, y) {mean(abs(y - x))}
```

```{r}
mae_white <- mae(prediction_quality_white, testdata_white$quality)
```

De mean absolute error voor witte wijn is `r mae_white`. Dit wil zeggen dat de voorspelde kwaliteit gemiddeld met `r round(mae_white, 2)` afwijkt van de werkelijke kwaliteit.



**Rode wijn:**

De data wordt gesplitst in een trainingsset en testset. Vervolgens wordt het model gemaakt met de trainingsset.

```{r}
dt_red = sort(sample(nrow(data_winequality_red), nrow(data_winequality_red)*.8))
traindata_red <- data_winequality_red[dt_red,]
testdata_red <- data_winequality_red[-dt_red,]

model_red <- lm(quality ~., data = traindata_red)
```

Nu het model gemaakt is, kan met de testset voorspellingen worden gemaakt. Het verschil tussen de werkelijke kwaliteit en de voorspelde kwaliteit wordt ook weergegeven.

```{r}
prediction_quality_red <- predict(model_red, newdata = testdata_red)

result_red <- data.frame(testdata_red$quality, prediction_quality_red, margin_of_error = testdata_red$quality - prediction_quality_red)

head(result_red)
```
Om de kwaliteit van het model te evalueren, wordt de mean absolute error gebruikt. Hoe kleiner de error, hoe beter het model. 

```{r}
mae <- function(x, y) {mean(abs(y - x))}
```

```{r}
mae_red <- mae(prediction_quality_red, testdata_red$quality)
```

De mean absolute error voor rode wijn is `r mae_red`. Dit wil zeggen dat de voorspelde kwaliteit gemiddeld met `r round(mae_red, 2)` afwijkt van de werkelijke kwaliteit.


### Algoritme 2: ...

-> Nu is het de bedoeling om na te denken over een 2de algoritme en daar een ML model rond te bouwen, te trainen, te testen en met voorspellingen te komen waarover je vervolgens kan reflecteren.<br />
-> MERK OP DAT BOVENSTAANDE VOORBEELDCODE ERG BEPERKT IS. DE CODE IS LOUTER ILLUSTRATIEF, MAAR GEEFT NIET WEER HOE BEKNOPT JULLIE TE WERK MOETEN GAAN. HET IS DE BEDOELING DAT JULLIE DUIDELIJKE CODE SCHRIJVEN, EN DEZE DOCUMENTEREN DOOR MIDDEL VAN UITLEG IN DIT DOCUMENT!



**Witte wijn:**
We kunnen opnieuw gebruik maken van dezelfde trainingsdataset en testdataset. Dit komt omdat we hier geen veranderingen op hebben uitgevoerd. Het eerste algoritme dat we gaan gebruiken om een model te maken is lda (Linear discriminant analysis). Zoals eerder aangegeven zullen we eerst onze dataset splitsen in een testdataset en een trainingsdataset

```{r}
head(dt_white)
dt_white_lda = sort(sample(nrow(data_winequality_white), nrow(data_winequality_white)*.8))
traindata_white_lda <- data_winequality_white[dt_white_lda,]
testdata_white_lda <- data_winequality_white[-dt_white_lda,]
head(traindata_white_lda$quality)
model_white_lda <- lda(quality ~., data = traindata_white_lda)
```

We hebben nu een model klaarstaan, dit kunnen we vervolgens gebruiken om een voorspelling te maken op de wijn. 

```{r}
prediction_quality_white_lda <- predict(model_white_lda, newdata = testdata_white_lda)
result_white_lda <- data.frame(testdata_white_lda$quality, prediction_quality_white_lda$class)
head(prediction_quality_white_lda$class, margin_of_error = testdata_white_lda$quality - prediction_quality_white_lda$class)
head(result_white_lda)
```

De functie predict kan aan de hand van het model een voorspelling maken op, in dit geval de wijnkwaliteit. Anders dan bij het 'lm' algoritme is dat er hier ronde getallen komen uit de prediction. Dit komt volgens mij omdat het 'lda' algoritme gebruik maakt van distincte categorieën. Uiteraard zijn de waarden die uit de voorspelling komen minder precies, maar blijft na het vergelijken met de testdata nog vrij accuraat waardoor dit algoritme zeker bruikbaar is. Het 'lda' lijkt ons wel echter niet de perfecte oplossing om de wijnkwaliteit te voorspellen omdat in dit geval mogelijks te veel zal worden afgerond waardoor je een iets minder accuraat antwoord krijgt. 

**Rode wijn:**

We kunnen vervolgens hetzelfde uitvoeren bij de rode wijn

```{r}
dt_red_lda = sort(sample(nrow(data_winequality_red), nrow(data_winequality_red)*.8))
traindata_red_lda <- data_winequality_red[dt_red_lda,]
testdata_red_lda <- data_winequality_red[-dt_red_lda,]
head(traindata_red_lda$quality)
model_red_lda <- lda(quality ~., data = traindata_red_lda)
plot(model_red_lda)
```

Het model staat nu klaar voor de rode wijn. Nu zullen we met dit model de voorspelling kunnen maken met de predict-functie.

```{r}
prediction_quality_red_lda <- predict(model_red_lda, newdata = testdata_red_lda)
result_red_lda <- data.frame(testdata_red_lda$quality, prediction_quality_red_lda$class)
head(prediction_quality_white_lda$class, margin_of_error = testdata_red_lda$quality - prediction_quality_red_lda$class)
head(result_red_lda)
```

### Algoritme 3: ...

-> Nu is het de bedoeling om na te denken over een 3de algoritme en daar een ML model rond te bouwen, te trainen, te testen en met voorspellingen te komen waarover je vervolgens kan reflecteren


**Witte wijn:**



**Rode wijn:**



### Conclusie



### Bronnen